###############################################################################
#                                                                             #
#                                                       03/Nov/2015  20:45:51 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\WangChangan\Desktop\K10小板定稿\KinetisDrivers\ #
#                    KinetisStart.c                                           #
#    Command line =  C:\Users\WangChangan\Desktop\K10小板定稿\KinetisDrivers\ #
#                    KinetisStart.c -D COMPILER_IAR -lCN                      #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\FLASH\List\" -lB "C:\Users\WangChangan\Desktop\K10 #
#                    小板定稿\IAR Files\FLASH\List\" -o                       #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\FLASH\Obj\" --no_cse --no_unroll --no_inline       #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Project_Headers\" -I                            #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\KinetisDrivers\" -I                             #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\ExtraFunction\" -I                              #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Hardware_Interface\" -I                         #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Make_Decision\" -I                              #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Math\" -I "C:\Users\WangChangan\Desktop\K10小板 #
#                    定稿\IAR Files\..\Original_Process\" -I                  #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Platform\" -I "C:\Users\WangChangan\Desktop\K10 #
#                    小板定稿\IAR Files\..\SD_System\" -I                     #
#                    "C:\Users\WangChangan\Desktop\K10小板定稿\IAR            #
#                    Files\..\Source\" -I "C:\Users\WangChangan\Desktop\K10小 #
#                    板定稿\IAR Files\..\System_Init\" -Ol                    #
#    List file    =  C:\Users\WangChangan\Desktop\K10小板定稿\IAR             #
#                    Files\FLASH\List\KinetisStart.lst                        #
#    Object file  =  C:\Users\WangChangan\Desktop\K10小板定稿\IAR             #
#                    Files\FLASH\Obj\KinetisStart.o                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\WangChangan\Desktop\K10小板定稿\KinetisDrivers\KinetisStart.c
      1          /************************************************************************************
      2          
      3          * KinetisStart.c
      4          
      5          * 定义Kinetis的启动代码以及必要的初始化代码。
      6          
      7          * 所支持的芯片:   K10系列与K60系列
      8          * 所支持的编译器: CodeWarrior 10.x or IAR 6.30
      9          
     10          * 该底层驱动由编译器自动生成的启动代码和飞思卡尔官方例程整理、修改而成。
     11          
     12          * 版权所有: 山东大学智能车工作室
     13          * 作者:     孙文健       (第六届摄像头)
     14          * 特别鸣谢: 纪成         (第四届摄像头)
     15          * PS: 该底层驱动是在技术大神、四朝元老――伟大的纪师兄的指导与帮助下完成的，故在此特别鸣谢。
     16          *     欲深入学习Kinetis，可以登录纪师兄的博客http://blog.chinaaet.com/jihceng0622
     17          
     18          * 程序版本: V1.02 
     19          * 更新时间: 2012-05-01
     20          
     21          *************************************************************************************/
     22          
     23          #include "./KinetisConfig.h"
     24          
     25          /* 变量与数据区声明 */
     26          extern K_int8u_t __SP_INIT[];
     27          extern K_int32u_t __Sword_Vector__[];
     28          
     29          #if   defined(COMPILER_CW)  
     30          
     31            extern const Ptr_VTOR_t VectorTable[];
     32          
     33            extern K_int8u_t __DATA_RAM[];              
     34            extern K_int8u_t __DATA_ROM[];
     35            extern K_int8u_t __DATA_END[];
     36            
     37          #elif defined(COMPILER_IAR)  
     38            
     39            extern const Ptr_VTOR_t __vector_table[];
     40            
     41            #pragma section = ".data"
     42            #pragma section = ".data_init"
     43            #pragma section = ".bss"
     44            #pragma section = "CodeRelocate"
     45            #pragma section = "CodeRelocateRam"
     46            
     47          #endif
     48          
     49          
     50          
     51          /* 外部函数声明 */
     52          extern void main(void);
     53          #if EN_InitHook_Kinetis != 0
     54            extern void HOOK_BeforeClk_Kinetis(void);
     55            extern void HOOK_AfterClk_Kinetis(void);
     56          #endif
     57            
     58            
     59          
     60          /* 全局变量定义 */
     61          #if EN_ResetType_Kinetis != 0
     62            KEEP_Data_Kinetis K_int16u_t ResetType_Kinetis;   /* 复位类型 */
     63          #endif
     64          
     65           
     66            
     67          /************************************************************************************************ 
     68          * DisWatchDog_Kinetis
     69          * 禁用开门狗
     70          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     71          static void DisWatchDog_Kinetis(void)
     72          {
     73            UNLOCK_WatchDog;                            /* 解锁开门狗 */
   \                     DisWatchDog_Kinetis:
   \   00000000   0x....             LDR.N    R0,??DataTable6  ;; 0x4005200e
   \   00000002   0xF24C 0x5120      MOVW     R1,#+50464
   \   00000006   0x8001             STRH     R1,[R0, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable6  ;; 0x4005200e
   \   0000000A   0xF64D 0x1128      MOVW     R1,#+55592
   \   0000000E   0x8001             STRH     R1,[R0, #+0]
     74            
     75            WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;  /* 禁用开门狗 */
   \   00000010   0x....             LDR.N    R0,??DataTable6_1  ;; 0x40052000
   \   00000012   0x8800             LDRH     R0,[R0, #+0]
   \   00000014   0xF64F 0x71FE      MOVW     R1,#+65534
   \   00000018   0x4008             ANDS     R0,R1,R0
   \   0000001A   0x....             LDR.N    R1,??DataTable6_1  ;; 0x40052000
   \   0000001C   0x8008             STRH     R0,[R1, #+0]
     76          }
   \   0000001E   0x4770             BX       LR               ;; return
     77          
     78          #if EN_CoreClkOut_Kinetis != 0
     79          /************************************************************************************************ 
     80          * OnCoreClk_Out
     81          * 用PTA6脚输出频率为CoreClock频率1/2的时钟信号
     82          ************************************************************************************************/
     83          static void OnCoreClk_Out(void)
     84          {
     85            /* Set the trace clock to the core clock frequency */
     86            SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;
     87            /* Enable the TRACE_CLKOUT pin function on PTA6 (alt7 function) */
     88            PORTA_PCR6 = (PORT_PCR_MUX(7));
     89          }
     90          #endif 
     91          #if EN_FlexClkOut_Kinetis != 0
     92          /************************************************************************************************ 
     93          * OnFlexClk_Out
     94          * 用PTC3脚输出FlexClock
     95          ************************************************************************************************/
     96          static void OnFlexClk_Out(void)
     97          {
     98            /* Enable the clock to the FlexBus module */
     99            SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
    100             /* Enable the FB_CLKOUT function on PTC3 (alt5 function) */
    101            PORTC_PCR3 = (PORT_PCR_MUX(5));
    102          }
    103          #endif
    104          /************************************************************************************************ 
    105          * SetPLL_Kinetis
    106          * 系统的锁相环设定，其完成的主要工作为: 设定CoreClock、BusClock、FlexClock、FlashClock
    107          * (设置的具体频率在KinetisConfig.h中配置)
    108          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    109          static void SetPLL_Kinetis(void)
    110          {
    111            K_int32u_t temp_reg;
    112            K_int8u_t  i;
    113          // First move to FBE mode
    114          // Enable external oscillator, RANGE=2, HGO=1, EREFS=1, LP=0, IRCS=0
    115            MCG_C2 = MCG_C2_RANGE(1) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
   \                     SetPLL_Kinetis:
   \   00000000   0x....             LDR.N    R0,??DataTable6_2  ;; 0x40064001
   \   00000002   0x211C             MOVS     R1,#+28
   \   00000004   0x7001             STRB     R1,[R0, #+0]
    116          
    117          // after initialization of oscillator release latched state of oscillator and GPIO
    118            SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable6_3  ;; 0x40048034
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x5080      ORRS     R0,R0,#0x10000000
   \   0000000E   0x....             LDR.N    R1,??DataTable6_3  ;; 0x40048034
   \   00000010   0x6008             STR      R0,[R1, #+0]
    119            LLWU_CS |= LLWU_CS_ACKISO_MASK;
   \   00000012   0x....             LDR.N    R0,??DataTable6_4  ;; 0x4007c008
   \   00000014   0x7800             LDRB     R0,[R0, #+0]
   \   00000016   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000001A   0x....             LDR.N    R1,??DataTable6_4  ;; 0x4007c008
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
    120            
    121          // Select external oscilator and Reference Divider and clear IREFS to start ext osc
    122          // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    123            MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
   \   0000001E   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40064000
   \   00000020   0x2198             MOVS     R1,#+152
   \   00000022   0x7001             STRB     R1,[R0, #+0]
    124          
    125            /* if we aren't using an osc input we don't need to wait for the osc to init */
    126          
    127            while (MCG_S & MCG_S_IREFST_MASK){}; // wait for Reference clock Status bit to clear
   \                     ??SetPLL_Kinetis_0:
   \   00000024   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40064006
   \   00000026   0x7800             LDRB     R0,[R0, #+0]
   \   00000028   0x06C0             LSLS     R0,R0,#+27
   \   0000002A   0xD4FB             BMI.N    ??SetPLL_Kinetis_0
    128          
    129            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; // Wait for clock status bits to show clock source is ext ref clk
   \                     ??SetPLL_Kinetis_1:
   \   0000002C   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40064006
   \   0000002E   0x7800             LDRB     R0,[R0, #+0]
   \   00000030   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x2802             CMP      R0,#+2
   \   00000038   0xD1F8             BNE.N    ??SetPLL_Kinetis_1
    130          
    131          // Now in FBE
    132          
    133            /* 设定PLL时钟 */
    134          #if CORE_CLK_Kinetis  <= 110
    135            MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/2 - 1);     /* PLLCLK == 2MHz */
    136          #else
    137            #if   REF_CLK_Kinetis % 3 == 0
    138              MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/3 - 1);   /* PLLCLK == 3MHz */
    139            #elif REF_CLK_Kinetis % 4 == 0
    140              MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/4 - 1);   /* PLLCLK == 4MHz */
   \   0000003A   0x....             LDR.N    R0,??DataTable6_7  ;; 0x40064004
   \   0000003C   0x2103             MOVS     R1,#+3
   \   0000003E   0x7001             STRB     R1,[R0, #+0]
    141            #elif REF_CLK_Kinetis % 5 == 0
    142              MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis*2/5 - 1); /* PLLCLK == 2.5MHz */
    143            #endif
    144          #endif 
    145            /*
    146             * Ensure MCG_C6 is at the reset default of 0. LOLIE disabled,
    147             * PLL disabled, clk monitor disabled, PLL VCO divider is clear 
    148             */  
    149            MCG_C6 = 0x0;
   \   00000040   0x....             LDR.N    R0,??DataTable6_8  ;; 0x40064005
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x7001             STRB     R1,[R0, #+0]
    150          
    151            /* 设定各时钟的分频数 */
    152            temp_reg = FMC_PFAPR; // store present value of FMC_PFAPR
   \   00000046   0x....             LDR.N    R0,??DataTable6_9  ;; 0x4001f000
   \   00000048   0x6800             LDR      R0,[R0, #+0]
    153            // set M0PFD through M7PFD to 1 to disable prefetch
    154            FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
    155                       | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
    156                       | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
   \   0000004A   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4001f000
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0xF451 0x017F      ORRS     R1,R1,#0xFF0000
   \   00000052   0x....             LDR.N    R2,??DataTable6_9  ;; 0x4001f000
   \   00000054   0x6011             STR      R1,[R2, #+0]
    157            
    158            // set clock dividers to desired value  
    159            SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0)       
    160                        | SIM_CLKDIV1_OUTDIV2(DIV_BusClk_Kinetis - 1) 
    161                        | SIM_CLKDIV1_OUTDIV3(DIV_FlexClk_Kinetis - 1) 
    162                        | SIM_CLKDIV1_OUTDIV4(DIV_FlashClk_Kinetis - 1);
   \   00000056   0x....             LDR.N    R1,??DataTable6_10  ;; 0x40048044
   \   00000058   0x....             LDR.N    R2,??DataTable6_11  ;; 0x1130000
   \   0000005A   0x600A             STR      R2,[R1, #+0]
    163            // wait for dividers to change
    164            for (i = 0 ; i < DIV_FlashClk_Kinetis ; i++) {}
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0xE000             B.N      ??SetPLL_Kinetis_2
   \                     ??SetPLL_Kinetis_3:
   \   00000060   0x1C49             ADDS     R1,R1,#+1
   \                     ??SetPLL_Kinetis_2:
   \   00000062   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000064   0x2904             CMP      R1,#+4
   \   00000066   0xD3FB             BCC.N    ??SetPLL_Kinetis_3
    165            FMC_PFAPR = temp_reg; // re-store original value of FMC_PFAPR  
   \   00000068   0x....             LDR.N    R1,??DataTable6_9  ;; 0x4001f000
   \   0000006A   0x6008             STR      R0,[R1, #+0]
    166            
    167            /* 设置倍频数,倍频数为VDIV+24 */
    168          #if CORE_CLK_Kinetis  <= 110
    169            MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/2 - 24); 
    170          #else
    171            #if   REF_CLK_Kinetis % 3 == 0
    172              MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/3 - 24); 
    173            #elif REF_CLK_Kinetis % 4 == 0
    174              MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/4 - 24);
   \   0000006C   0x....             LDR.N    R0,??DataTable6_8  ;; 0x40064005
   \   0000006E   0x2146             MOVS     R1,#+70
   \   00000070   0x7001             STRB     R1,[R0, #+0]
    175            #elif REF_CLK_Kinetis % 5 == 0
    176              MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis*2/5 - 24); 
    177            #endif
    178          #endif
    179            
    180            while (!(MCG_S & MCG_S_PLLST_MASK)){}; // wait for PLL status bit to set
   \                     ??SetPLL_Kinetis_4:
   \   00000072   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40064006
   \   00000074   0x7800             LDRB     R0,[R0, #+0]
   \   00000076   0x0680             LSLS     R0,R0,#+26
   \   00000078   0xD5FB             BPL.N    ??SetPLL_Kinetis_4
    181          
    182            while (!(MCG_S & MCG_S_LOCK_MASK)){}; // Wait for LOCK bit to set
   \                     ??SetPLL_Kinetis_5:
   \   0000007A   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40064006
   \   0000007C   0x7800             LDRB     R0,[R0, #+0]
   \   0000007E   0x0640             LSLS     R0,R0,#+25
   \   00000080   0xD5FB             BPL.N    ??SetPLL_Kinetis_5
    183          
    184          // Now running PBE Mode
    185          
    186          // Transition into PEE by setting CLKS to 0
    187          // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
    188            MCG_C1 &= ~MCG_C1_CLKS_MASK;
   \   00000082   0x....             LDR.N    R0,??DataTable6_5  ;; 0x40064000
   \   00000084   0x7800             LDRB     R0,[R0, #+0]
   \   00000086   0xF010 0x003F      ANDS     R0,R0,#0x3F
   \   0000008A   0x....             LDR.N    R1,??DataTable6_5  ;; 0x40064000
   \   0000008C   0x7008             STRB     R0,[R1, #+0]
    189          
    190          // Wait for clock status bits to update
    191            while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
   \                     ??SetPLL_Kinetis_6:
   \   0000008E   0x....             LDR.N    R0,??DataTable6_6  ;; 0x40064006
   \   00000090   0x7800             LDRB     R0,[R0, #+0]
   \   00000092   0xF3C0 0x0081      UBFX     R0,R0,#+2,#+2
   \   00000096   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000098   0x2803             CMP      R0,#+3
   \   0000009A   0xD1F8             BNE.N    ??SetPLL_Kinetis_6
    192          } 
   \   0000009C   0x4770             BX       LR               ;; return
    193          
    194          /************************************************************************************************ 
    195          * OnGPIOClk_Kinetis
    196          * 使能GPIO时钟 
    197          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    198          static void OnGPIOClk_Kinetis(void)
    199          {
    200            /* 使能IO口时钟 */
    201            SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
    202                       | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
    203                       | SIM_SCGC5_PORTE_MASK ;
   \                     OnGPIOClk_Kinetis:
   \   00000000   0x....             LDR.N    R0,??DataTable6_12  ;; 0x40048038
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0xF450 0x5078      ORRS     R0,R0,#0x3E00
   \   00000008   0x....             LDR.N    R1,??DataTable6_12  ;; 0x40048038
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    204          }
   \   0000000C   0x4770             BX       LR               ;; return
    205          /************************************************************************************************ 
    206          * Init_Clock_Kinetis
    207          * 初始化系统时钟,其完成的主要工作有: 设置系统时钟、使能外部基准时钟、将系统时钟通过IO口输出(可选) 
    208          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    209          static void Init_Clock_Kinetis(void)
    210          {      
   \                     Init_Clock_Kinetis:
   \   00000000   0xB580             PUSH     {R7,LR}
    211             /* 设定系统时钟 */
    212            SetPLL_Kinetis();
   \   00000002   0x.... 0x....      BL       SetPLL_Kinetis
    213            
    214            /* 使能外部基准时钟(很多模块需要用到该时钟) */
    215            OSC_CR |= OSC_CR_ERCLKEN_MASK;
   \   00000006   0x....             LDR.N    R0,??DataTable6_13  ;; 0x40065000
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF050 0x0080      ORRS     R0,R0,#0x80
   \   0000000E   0x....             LDR.N    R1,??DataTable6_13  ;; 0x40065000
   \   00000010   0x7008             STRB     R0,[R1, #+0]
    216            
    217          #if  EN_CoreClkOut_Kinetis != 0
    218            /* 用PTA6输出CoreClock/2*/
    219            OnCoreClk_Out();
    220          #endif
    221            
    222          #if EN_FlexClkOut_Kinetis != 0  
    223            /* 用PTC3输出FlexClock */
    224            OnFlexClk_Out();
    225          #endif
    226          }
   \   00000012   0xBD01             POP      {R0,PC}          ;; return
    227          #if EN_ResetType_Kinetis != 0
    228          /************************************************************************************************ 
    229          * ReadResetType_Kinetis
    230          * 读取寄存器ReadResetType_Kinetis以判定系统的复位类型
    231          ************************************************************************************************/
    232          static void ReadResetType_Kinetis(void)
    233          {
    234            ResetType_Kinetis = MC_SRSH;
    235            ResetType_Kinetis <<= 8;
    236            ResetType_Kinetis |= MC_SRSL;
    237          }
    238          #endif
    239          /************************************************************************************************ 
    240          * FillBss_0_Kinetis
    241          * 将"BSS"数据区初始化为0
    242          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    243          static void FillBss_0_Kinetis(void)
    244          { 
    245          #if   defined(COMPILER_CW)  
    246            
    247            extern K_int8u_t __START_BSS[];
    248            extern K_int8u_t __END_BSS[];
    249            
    250            memset(__START_BSS, 0, (__END_BSS - __START_BSS));  
    251            
    252          #elif defined(COMPILER_IAR) 
    253            
    254            K_int8u_t *bss_start = __section_begin(".bss");
   \                     FillBss_0_Kinetis:
   \   00000000   0x....             LDR.N    R0,??DataTable6_14
    255            K_int8u_t *bss_end   = __section_end(".bss");
   \   00000002   0x....             LDR.N    R1,??DataTable6_15
    256            K_int32u_t n = (K_int32u_t)bss_end - (K_int32u_t)bss_start;;
   \   00000004   0x1A09             SUBS     R1,R1,R0
    257            
    258            if(n != 0)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD103             BNE.N    ??FillBss_0_Kinetis_0
   \   0000000A   0xE006             B.N      ??FillBss_0_Kinetis_1
    259            {
    260              while(n--)
    261              {
    262                *bss_start++ = 0;
   \                     ??FillBss_0_Kinetis_2:
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x7002             STRB     R2,[R0, #+0]
   \   00000010   0x1C40             ADDS     R0,R0,#+1
    263              }
   \                     ??FillBss_0_Kinetis_0:
   \   00000012   0x000A             MOVS     R2,R1
   \   00000014   0x1E51             SUBS     R1,R2,#+1
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F8             BNE.N    ??FillBss_0_Kinetis_2
    264            }
    265            
    266          #endif  
    267          }
   \                     ??FillBss_0_Kinetis_1:
   \   0000001A   0x4770             BX       LR               ;; return
    268          /************************************************************************************************ 
    269          * RomToRam_Kinetis
    270          * 将部分ROM中的数据转移至RAM中
    271          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    272          static void RomToRam_Kinetis(void)
    273          {
   \                     RomToRam_Kinetis:
   \   00000000   0xB470             PUSH     {R4-R6}
    274          #if   defined(COMPILER_CW) 
    275            
    276            K_int32u_t n = (K_int32u_t)__DATA_END - (K_int32u_t)__DATA_RAM;
    277            K_int8u_t *ptr1 = __DATA_RAM, *ptr2 = __DATA_ROM;
    278            
    279          #elif defined(COMPILER_IAR) 
    280            
    281            K_int32u_t n = (K_int32u_t)__section_end(".data_init") - (K_int32u_t)__section_begin(".data_init");
   \   00000002   0x....             LDR.N    R0,??DataTable6_16
   \   00000004   0x....             LDR.N    R1,??DataTable6_17
   \   00000006   0x1A40             SUBS     R0,R0,R1
    282            K_int8u_t *ptr1 = __section_begin(".data"), *ptr2 = __section_begin(".data_init");
   \   00000008   0x....             LDR.N    R1,??DataTable6_18
   \   0000000A   0x....             LDR.N    R2,??DataTable6_17
    283            
    284            K_int8u_t* code_relocate_ram = __section_begin("CodeRelocateRam");
   \   0000000C   0x....             LDR.N    R3,??DataTable6_19
    285            K_int8u_t* code_relocate = __section_begin("CodeRelocate");
   \   0000000E   0x....             LDR.N    R4,??DataTable6_20
    286            K_int8u_t* code_relocate_end = __section_end("CodeRelocate");
   \   00000010   0x....             LDR.N    R5,??DataTable6_21
    287            
    288          #endif  
    289            
    290            if(n != 0)
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD006             BEQ.N    ??RomToRam_Kinetis_0
    291            {
    292              do
    293              {
    294                *ptr1++ = *ptr2++;  
   \                     ??RomToRam_Kinetis_1:
   \   00000016   0x7816             LDRB     R6,[R2, #+0]
   \   00000018   0x700E             STRB     R6,[R1, #+0]
   \   0000001A   0x1C52             ADDS     R2,R2,#+1
   \   0000001C   0x1C49             ADDS     R1,R1,#+1
    295              } while(--n);  
   \   0000001E   0x1E40             SUBS     R0,R0,#+1
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1F8             BNE.N    ??RomToRam_Kinetis_1
    296            } 
    297            
    298          #if defined(COMPILER_IAR)
    299            
    300            /* Copy functions from ROM to RAM */
    301            n = (K_int32u_t)code_relocate_end - (K_int32u_t)code_relocate;
   \                     ??RomToRam_Kinetis_0:
   \   00000024   0x1B28             SUBS     R0,R5,R4
    302            if(n != 0)
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD104             BNE.N    ??RomToRam_Kinetis_2
   \   0000002A   0xE007             B.N      ??RomToRam_Kinetis_3
    303            {
    304              while (n--)
    305              {
    306                *code_relocate_ram++ = *code_relocate++;
   \                     ??RomToRam_Kinetis_4:
   \   0000002C   0x7821             LDRB     R1,[R4, #+0]
   \   0000002E   0x7019             STRB     R1,[R3, #+0]
   \   00000030   0x1C64             ADDS     R4,R4,#+1
   \   00000032   0x1C5B             ADDS     R3,R3,#+1
    307              }
   \                     ??RomToRam_Kinetis_2:
   \   00000034   0x0001             MOVS     R1,R0
   \   00000036   0x1E48             SUBS     R0,R1,#+1
   \   00000038   0x2900             CMP      R1,#+0
   \   0000003A   0xD1F7             BNE.N    ??RomToRam_Kinetis_4
    308            }
    309            
    310          #endif
    311          }
   \                     ??RomToRam_Kinetis_3:
   \   0000003C   0xBC70             POP      {R4-R6}
   \   0000003E   0x4770             BX       LR               ;; return
    312          /************************************************************************************************ 
    313          * Init_VTOR_Kinetis
    314          * 初始化中断向量表,将系统默认的中断向量表改为自定以的中断向量表 
    315          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    316          static void Init_VTOR_Kinetis(void)
    317          {
    318            K_int32u_t n = 120;
   \                     Init_VTOR_Kinetis:
   \   00000000   0x2078             MOVS     R0,#+120
    319            K_int32u_t * ptr1 , * ptr2;
    320            
    321            ptr1 = (K_int32u_t *)__Sword_Vector__;
   \   00000002   0x....             LDR.N    R1,??DataTable6_22
    322          #if   defined(COMPILER_CW)   
    323            ptr2 = (K_int32u_t *)VectorTable;
    324          #elif defined(COMPILER_IAR) 
    325            ptr2 = (K_int32u_t *)__vector_table;
   \   00000004   0x....             LDR.N    R2,??DataTable6_23
    326          #endif  
    327            
    328            /* 将向量表赋值到指定区域 */
    329          /* 
    330              注意: SCB_VTOR的低位只能是0,必须保证".lcf"(".icf")中定义的__Sword_Vector__符合该条件.
    331          */
    332            if(ptr1 != ptr2)
   \   00000006   0x4291             CMP      R1,R2
   \   00000008   0xD006             BEQ.N    ??Init_VTOR_Kinetis_0
    333            {
    334              do
    335              {
    336                *ptr1++ = *ptr2++;
   \                     ??Init_VTOR_Kinetis_1:
   \   0000000A   0x6813             LDR      R3,[R2, #+0]
   \   0000000C   0x600B             STR      R3,[R1, #+0]
   \   0000000E   0x1D12             ADDS     R2,R2,#+4
   \   00000010   0x1D09             ADDS     R1,R1,#+4
    337              } while(--n);
   \   00000012   0x1E40             SUBS     R0,R0,#+1
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD1F8             BNE.N    ??Init_VTOR_Kinetis_1
    338            }
    339            
    340            SCB_VTOR = (K_int32u_t)__Sword_Vector__;
   \                     ??Init_VTOR_Kinetis_0:
   \   00000018   0x....             LDR.N    R0,??DataTable6_24  ;; 0xe000ed08
   \   0000001A   0x....             LDR.N    R1,??DataTable6_22
   \   0000001C   0x6001             STR      R1,[R0, #+0]
    341          }
   \   0000001E   0x4770             BX       LR               ;; return
    342          
    343          #if   defined(COMPILER_CW)
    344          /************************************************************************************************ 
    345          * StartUp_Kinetis
    346          * Kinetis的启动代码(汇编语言函数,仅针对CodeWarrior 10.x)
    347          * 即系统上电时处理器执行的第一段代码,负责完成ARM所必须的初始化操作,并跳转到用户的入口程序
    348          ************************************************************************************************/
    349          asm void StartUp_Kinetis(void)
    350          {
    351            CPSID   i                         /* 关中断 */    
    352            
    353            bl   DisWatchDog_Kinetis          /* 禁用开门狗 */  
    354            
    355            lda  r0,__SP_INIT                 /* 初始化SP指针 */ 
    356            mov  sp,r0
    357            sub  sp,#4
    358            mov  r0,#0
    359            mvn  r0,r0
    360            str  r0,[sp,#0]
    361            add  sp,#4
    362            
    363            bl  OnGPIOClk_Kinetis             /* 开启GPIO时钟 */
    364            
    365          #if EN_InitHook_Kinetis != 0      
    366            bl  HOOK_BeforeClk_Kinetis        /* 执行用户定义的初始化接口 */
    367          #endif
    368            
    369            bl  Init_Clock_Kinetis            /* 初始化系统时钟 */
    370            
    371          #if EN_InitHook_Kinetis != 0
    372            bl  HOOK_AfterClk_Kinetis         /* 执行用户定义的初始化接口 */
    373          #endif  
    374            
    375          #if EN_ResetType_Kinetis != 0  
    376            bl  ReadResetType_Kinetis         /* 读取复位类型 */
    377          #endif  
    378            
    379            bl  RomToRam_Kinetis              /* 将部分ROM中的数据转移到RAM中 */  
    380            bl  FillBss_0_Kinetis             /* 清零BSS区域 */
    381            bl  Init_VTOR_Kinetis             /* 初始化中断向量表 */     
    382                
    383            bl  main                          /* 跳转到main函数 */
    384          }
    385          #elif defined(COMPILER_IAR)
    386          /************************************************************************************************ 
    387          * Start_C_Kinetis
    388          * Kinetis的C语言启动代码,被汇编语言程序段StartUp_Kinetis调用
    389          * 负责完成ARM所必须的初始化操作,并跳转到用户的入口程序
    390          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    391          void Start_C_Kinetis(void)
    392          {
   \                     Start_C_Kinetis:
   \   00000000   0xB580             PUSH     {R7,LR}
    393            DisWatchDog_Kinetis();            /* 禁用开门狗 */  
   \   00000002   0x.... 0x....      BL       DisWatchDog_Kinetis
    394            
    395            OnGPIOClk_Kinetis();              /* 开启GPIO时钟 */
   \   00000006   0x.... 0x....      BL       OnGPIOClk_Kinetis
    396            
    397          #if EN_InitHook_Kinetis != 0      
    398            HOOK_BeforeClk_Kinetis()          /* 执行用户定义的初始化接口 */
    399          #endif
    400            
    401            Init_Clock_Kinetis();             /* 初始化系统时钟 */
   \   0000000A   0x.... 0x....      BL       Init_Clock_Kinetis
    402            
    403          #if EN_InitHook_Kinetis != 0
    404            HOOK_AfterClk_Kinetis();          /* 执行用户定义的初始化接口 */
    405          #endif  
    406            
    407          #if EN_ResetType_Kinetis != 0  
    408            ReadResetType_Kinetis();          /* 读取复位类型 */
    409          #endif  
    410            
    411            RomToRam_Kinetis();               /* 将部分ROM中的数据转移到RAM中 */  
   \   0000000E   0x.... 0x....      BL       RomToRam_Kinetis
    412            FillBss_0_Kinetis();              /* 清零BSS区域 */
   \   00000012   0x.... 0x....      BL       FillBss_0_Kinetis
    413            Init_VTOR_Kinetis();              /* 初始化中断向量表 */     
   \   00000016   0x.... 0x....      BL       Init_VTOR_Kinetis
    414                
    415            main();                           /* 跳转到main函数 */
   \   0000001A   0x.... 0x....      BL       main
    416          }
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x4005200E         DC32     0x4005200e

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x40052000         DC32     0x40052000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x40064001         DC32     0x40064001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x40048034         DC32     0x40048034

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x4007C008         DC32     0x4007c008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x40064000         DC32     0x40064000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x40064006         DC32     0x40064006

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x40064004         DC32     0x40064004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x40064005         DC32     0x40064005

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x4001F000         DC32     0x4001f000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x40048044         DC32     0x40048044

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x01130000         DC32     0x1130000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x40048038         DC32     0x40048038

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x40065000         DC32     0x40065000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     SFB(`.bss`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     SFE(`.bss`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     SFE(`.data_init`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x........         DC32     SFB(`.data_init`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     SFB(`.data`)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x........         DC32     SFB(CodeRelocateRam)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   0x........         DC32     SFB(CodeRelocate)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_21:
   \   00000000   0x........         DC32     SFE(CodeRelocate)

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_22:
   \   00000000   0x........         DC32     __Sword_Vector__

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_23:
   \   00000000   0x........         DC32     __vector_table

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_24:
   \   00000000   0xE000ED08         DC32     0xe000ed08
    417          #endif

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  DisWatchDog_Kinetis
        0  FillBss_0_Kinetis
        8  Init_Clock_Kinetis
             8 -> SetPLL_Kinetis
        0  Init_VTOR_Kinetis
        0  OnGPIOClk_Kinetis
       12  RomToRam_Kinetis
        0  SetPLL_Kinetis
        8  Start_C_Kinetis
             8 -> DisWatchDog_Kinetis
             8 -> FillBss_0_Kinetis
             8 -> Init_Clock_Kinetis
             8 -> Init_VTOR_Kinetis
             8 -> OnGPIOClk_Kinetis
             8 -> RomToRam_Kinetis
             8 -> main


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_22
       4  ??DataTable6_23
       4  ??DataTable6_24
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      32  DisWatchDog_Kinetis
      28  FillBss_0_Kinetis
      20  Init_Clock_Kinetis
      32  Init_VTOR_Kinetis
      14  OnGPIOClk_Kinetis
      64  RomToRam_Kinetis
     158  SetPLL_Kinetis
      32  Start_C_Kinetis

 
 480 bytes in section .text
 
 480 bytes of CODE memory

Errors: none
Warnings: none
